The MicroProfile is a set of specifications that intends to optimize Enterprise Java for the microservices architecture by creating multiple implementations and collaborating on common areas of interest to standardization.

MicroProfile allows Jakarta EE developers to leverage their current skill set while shifting their focus from traditional monolithic applications to microservices. 

Its API provides a foundation to build microservices-based applications by using a subset of the Jakarta EE standards and extending them to address common microservices patterns. 

Eclipse MicroProfile is specified under the Eclipse Foundation and is implemented by SmallRye.

> Eclipse MicroProfile does not rely on Jakarta EE, it supports some of its specifications. Created in 1998, Java EE can be seen as an extension of the Java SE. It is a set of specifications to help build distributed, transactional, and secure applications. It is developed using the JCP with contributions and several organizations. In 2017, Java EE was donated to the Eclipse Foundation and renamed Jakarta EE and governed by the Jakarta EE Working Group. Jakarta EE 8 is based on the Java EE 8 technologies. Future versions will be driven by Eclipse Foundation.

Eclipse Foundation, created by IBM in 2001, is an independent, non-profit entity that acts as a steward for the Eclipse open source software development community.

SmallRye is an open source project that implements the Eclipse MicroProfile specifications. Several open source 24 projects integrate SmallRye such as Thorntail, WildFly, WebSphere Liberty and Quarkus.

**MicroProfile Specifications**

Last stable version is version 3.3 and the 4.0-RC1 release is now available. 

We will find specifications that come from Jakarta EE (e.g. CDI, JAX-RS, etc.) as well as brand new specifications that were created with microservices in mind.

Context and Dependency Injection (CDI) 2.0

> CDI or Context and Dependency Injection is a fundamental API in Jakarta EE or MicroProfile. 
>
> It turns nearly every component into an injectable, interceptable, and manageable bean. CDI is built on the concept of "loose coupling" and "strong typing". 
>
> Decoupling goes further by bringing interceptors, decorators, and events to the entire platform. CDI homogenizes scopes among beans, as well as context and life cycle management. 
>
> > Quarkus uses CDI extensively, but it is not a full CDI implementation verified by the TCK. CDI being runtime based and not compile time-based, Quarkus decided only to implement the most useful CDI features that could be generated at compile time.

Java API for RESTful Web Services (JAX-RS) 2.1

> JAX-RS or Java API for RESTful Web Services is a specification to create web services based on the Representational State Transfer (REST) architectural style.
>
> JAX-RS provides a set of annotations and classes/interfaces to simplify REST endpoints' development and deployment.
>
> It also brings a client API to invoke REST endpoints programmatically. 

JSON Binding (JSON-B) 1.0

> JSON-B or JSON Binding is a standard binding layer for converting Java objects to/ from JSON documents. It defines a default mapping algorithm for converting existing Java classes to JSON while enabling developers to customize the mapping process through Java annotations.

JSON Processing (JSON-P) 1.1 

> JSON-P or JSON Processing is a specification for processing JSON in Java. The processing includes mechanisms to parse, generate, transform, and query JSON data. 
> At the same time, it provides a mechanism to produce and consume JSON by streaming like StAX (Streaming API for XML) for XML.

Common Annotations 1.3

> Common Annotations provide annotations for common semantic concepts across various individual technologies in the Java SE, Jakarta EE, and MicroProfile platforms. 
>
> @DenyAll, @PermitAll, @RolesAllowed, @RunAs are standard annotations based on a simple role-based security model.
>
> @Priority can be applied to classes or parameters to indicate in what order they should be used.
>
> @PostConstruct, @PreDestroy are used on a method that needs to be executed after being created or before being removed by the container.
>
> @Generated marks the source code that has been generated by some other API.

Configuration 1.4

> Each microservice has its own configuration. But sometimes, microservices might want to share a common configuration. 
>
> In that case, it can be helpful to access configurations from multiple sources homogeneously. 
>
> MicroProfile Configuration provides an API to retrieve configuration properties through several sources (internal and external to the application), dependency injection, or lookup.

Fault Tolerance 2.1 

> As the number of services increases, the chances of any service outage also can increase. If a concerned service does not react as expected, the app needs to compensate for this unusual situation. MicroProfile Fault Tolerance lets build microservice architecture to be resilient and fault-tolerant by design. This enables issue detection and automatic handling.  

Health 2.2

>The MicroProfile Health API allows applications to provide information about their state to external viewers. This API helps cloud environments where automated processes must identify if microservices should be discarded or restarted. 

JWT 1.1

>MicroProfile JWT provides Role-Based Access Control (RBAC) using OpenID Connect (OIDC) and JSON Web Tokens (JWT). Due to the stateless character of microservices, the solution must easily offer security context propagation. This is done by passing tokens around microservices invocations.

Metrics 2.3

>MicroProfile Metrics provides a unified way to export and gather monitoring data to management agents. 
>
>The metrics can be read remotely using a JSON or OpenMetrics format to be processed by additional tools such as Prometheus and stored for analysis and visualization.  

OpenAPI 1.1

>MicroProfile OpenAPI provides a Java API for the OpenAPI v3 specification to expose REST API documentation. It aims to provide a set of Java interfaces and programming models to produce OpenAPI v3 documents from their JAX-RS endpoints natively. 

OpenTracing 1.3

> Requests often span multiple services (e.g., database queries, publishing messages, etc.). MicroProfile OpenTracing defines an API to help services participate in a distributed tracing environment easily. Deprecated in MicroProfile 3.3 and replaced by OpenTelemetry.

REST Client 1.4

> MicroProfile REST Client provides a type-safe approach using proxies and annotations for invoking RESTful services over HTTP. The MicroProfile REST Client builds upon the JAXRS 2.1 APIs for consistency and ease-of-use.

There are other specifications are either being incubated or still in progress.

Context Propagation

> Eclipse Context Propagation allows transferring thread context.

Reactive Messaging

> Eclipse Reactive Messaging is made for building event-driven, data streaming, and event-sourcing applications.

Mutiny 

> Mutiny provides a guided API, making reactive programming easy. 
> Mutiny was designed years after existing reactive programming libraries. 
>
> It is based on many developers' experience, lost in an endless sequence of map and flatMap operators. 
>
> Mutiny does not provide as many operators as the other reactive libraries, focusing instead on the most used operators. 
>
> Furthermore, it helps developers by providing a more guided API, which avoids having classes with hundreds of methods to choose from.